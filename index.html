<!DOCTYPE html>
<html lang="en" class="dark">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <meta name="mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="theme-color" content="#0ea5e9" />
  <title>Translator</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
  <script src="https://cdn.tailwindcss.com"></script>
  <!-- Favicon (blue background badge with provided icon centered) -->
  <link rel="icon" href="./image.png" type="image/png" />
  <style>
    :root { color-scheme: dark light; }
    body { font-family: 'Inter', sans-serif; }
    /* Smooth show/hide */
    .fade-in { animation: fadeIn .25s ease-in; }
    @keyframes fadeIn { from {opacity:0; transform: translateY(2px)} to {opacity:1; transform: translateY(0)} }
    /* Spinner */
    .spinner { width: 20px; height: 20px; border: 3px solid rgba(255,255,255,.35); border-top-color: #fff; border-radius: 50%; animation: spin 1s linear infinite; }
    @keyframes spin { to { transform: rotate(360deg) } }
  </style>
  <script>
    // Respect system dark mode; default to dark if no preference stored
    try {
      const prefersDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
      if (localStorage.theme === 'dark' || (!('theme' in localStorage) && prefersDark)) {
        document.documentElement.classList.add('dark');
      } else if (localStorage.theme === 'light') {
        document.documentElement.classList.remove('dark');
      } // else keep default 'dark' class from HTML
    } catch (e) {}
  </script>
</head>
<body class="min-h-screen bg-neutral-900 text-neutral-200 sm:p-6 p-3">
  <div class="max-w-3xl mx-auto">
    <!-- Header / App badge -->
    <div class="flex items-center gap-3 mb-5">
      <div class="w-10 h-10 rounded-2xl flex items-center justify-center shadow ring-1 ring-black/10" style="background: #0ea5e9">
        <img src="image.png" alt="App Icon" class="w-6 h-6 object-contain" />
      </div>
      <h1 class="text-2xl font-semibold tracking-tight">Translator</h1>
      <div class="ml-auto text-xs text-neutral-400">Dark mode ready</div>
    </div>

    <div class="bg-neutral-800/60 backdrop-blur rounded-2xl shadow-xl ring-1 ring-white/5 p-4 sm:p-6 space-y-5">
      <!-- Provider status + Configure -->
      <div class="flex flex-col sm:flex-row sm:items-center gap-3">
        <div class="text-sm font-medium">
          <span id="providerStatusText" class="text-red-400">Configure Translator ⚠</span>
        </div>
        <button id="toggleProviderBtn" class="sm:ml-auto inline-flex items-center justify-center px-3 py-2 rounded-lg bg-neutral-700 hover:bg-neutral-600 text-sm">
          Configure API Key
          <svg id="providerChevron" class="w-4 h-4 ml-1" viewBox="0 0 24 24" fill="none" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"/></svg>
        </button>
      </div>

      <!-- API Key Configuration (same format as before) -->
      <div id="apiConfigSection" class="hidden">
        <div class="rounded-xl border border-sky-500/30 bg-sky-500/10 p-4 space-y-3 fade-in">
          <div class="flex items-center justify-between">
            <h3 class="text-base font-medium text-sky-300">API Configuration</h3>
          </div>
          <div class="space-y-3">
            <div class="flex flex-col sm:flex-row gap-3">
              <div class="flex-1">
                <input type="password" id="apiKeyInput" placeholder="Enter your Gemini API key..." class="w-full p-3 rounded-lg bg-neutral-900 border border-neutral-700 focus:outline-none focus:ring-2 focus:ring-sky-500" />
              </div>
              <button id="toggleApiKey" class="px-3 py-2 rounded-lg bg-neutral-700 hover:bg-neutral-600" title="Show/Hide API key">
                <svg id="eyeIcon" class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"/><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z"/></svg>
              </button>
              <button id="saveApiKey" class="px-4 py-2 rounded-lg bg-sky-600 hover:bg-sky-500 text-white font-medium">Save Key</button>
            </div>
            <div class="text-sm text-sky-300/90">
              <p>🔑 <strong>How to get your API key:</strong></p>
              <ol class="ml-4 mt-1 list-decimal space-y-1">
                <li>Visit <a href="https://aistudio.google.com/app/apikey" target="_blank" class="text-sky-300 underline">Google AI Studio</a></li>
                <li>Sign in with your Google account</li>
                <li>Click "Create API key" and copy it</li>
                <li>Paste it above and click "Save Key"</li>
              </ol>
              <p class="mt-2 text-xs">🔒 Your API key is stored locally in your browser and never shared.</p>
            </div>
          </div>
        </div>
      </div>

      <!-- Language Selection (mobile-first) -->
      <div class="grid grid-cols-1 sm:grid-cols-[1fr_auto_1fr] gap-3">
        <div>
          <label class="block text-xs text-neutral-400 mb-1">From</label>
          <select id="inputLang" class="w-full p-3 rounded-lg bg-neutral-900 border border-neutral-700 focus:outline-none focus:ring-2 focus:ring-sky-500"></select>
        </div>
        <div class="sm:self-end sm:pb-1">
          <button id="swapBtn" class="p-2 rounded-lg bg-neutral-700 hover:bg-neutral-600" title="Swap languages">
            <svg class="w-5 h-5" viewBox="0 0 24 24" fill="none" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 7h12m0 0l-4-4m4 4l-4 4m0 6H4m0 0l4 4m-4-4l4-4"/></svg>
          </button>
        </div>
        <div>
          <label class="block text-xs text-neutral-400 mb-1">To</label>
          <select id="outputLang" class="w-full p-3 rounded-lg bg-neutral-900 border border-neutral-700 focus:outline-none focus:ring-2 focus:ring-sky-500"></select>
        </div>
      </div>

      <!-- Korean Formality & Dialect (preserved) -->
      <div id="formalityContainer" class="hidden space-y-4">
        <div>
          <label class="block text-xs text-neutral-400 mb-1">Korean Formality Level</label>
          <select id="formalityLevel" class="w-full p-3 rounded-lg bg-neutral-900 border border-neutral-700 focus:outline-none focus:ring-2 focus:ring-sky-500">
            <option value="하소서체 (Hasoseo-che)">하소서체 (Hasoseo-che) — Extremely formal, archaic</option>
            <option value="하십시오체 (Hasipsio-che)">십시오체 (Hasipsio-che) — Formal polite</option>
            <option value="해요체 (Haeyo-che)" selected>해요체 (Haeyo-che) — Polite informal (default)</option>
            <option value="하게체 (Hage-che)">하게체 (Hage-che) — Semi-formal</option>
            <option value="하오체 (Hao-che)">하오체 (Hao-che) — Old polite</option>
            <option value="한다체 (Handa-che)">한다체 (Handa-che) — Plain/neutral</option>
            <option value="해체 (Hae-che)">해체 (Hae-che) — Casual/intimate (spoken)</option>
            <option value="반말체 (Banmal-che)">반말체 (Banmal-che) — Pure casual/texting style (chat/slang)</option>
          </select>
        </div>
        <div>
          <label class="block text-xs text-neutral-400 mb-1">Korean Dialect (Satoori)</label>
          <select id="dialectLevel" class="w-full p-3 rounded-lg bg-neutral-900 border border-neutral-700 focus:outline-none focus:ring-2 focus:ring-sky-500">
            <option value="Standard Korean" selected>Standard Korean (표준어) — No dialect</option>
            <option value="Seoul/Gyeonggi Dialect">Seoul/Gyeonggi Dialect (서울/경기 사투리)</option>
            <option value="Gangwon Dialect">Gangwon Dialect (강원 사투리)</option>
            <option value="Chungcheong Dialect">Chungcheong Dialect (충청 사투리)</option>
            <option value="Gyeongsang Dialect">Gyeongsang Dialect (경상 사투리)</option>
            <option value="Jeolla Dialect">Jeolla Dialect (전라 사투리)</option>
            <option value="Jeju Dialect">Jeju Dialect (제주 사투리 / 제주어)</option>
          </select>
        </div>
      </div>

      <!-- Japanese Formality & Dialect -->
      <div id="jpFormalityContainer" class="hidden space-y-4">
        <div>
          <label class="block text-xs text-neutral-400 mb-1">Japanese Formality Level</label>
          <select id="jpFormalityLevel" class="w-full p-3 rounded-lg bg-neutral-900 border border-neutral-700 focus:outline-none focus:ring-2 focus:ring-sky-500">
            <option value="Plain Form">普通語 (Futsūgo) / 砕けた (Kudaketa) — Plain form</option>
            <option value="Casual">タメ語 (Tamego) — Casual between equals</option>
            <option value="Polite">丁寧語 (Teineigo) — Polite</option>
            <option value="Respectful">尊敬語 (Sonkeigo) — Respectful</option>
            <option value="Humble">謙譲語 (Kenjōgo) — Humble</option>
            <option value="Casual Slang">ネットスラング / 若者言葉 — Casual slang & texting</option>
          </select>
        </div>

        <div>
          <label class="block text-xs text-neutral-400 mb-1">Japanese Dialect</label>
          <select id="jpDialectLevel" class="w-full p-3 rounded-lg bg-neutral-900 border border-neutral-700 focus:outline-none focus:ring-2 focus:ring-sky-500">
            <optgroup label="Eastern Japanese Dialects">
              <option value="Kanto">関東方言 (Kanto Dialect)</option>
              <option value="Tohoku">東北方言 (Tōhoku Dialect)</option>
              <option value="Hokkaido">北海道方言 (Hokkaidō Dialect)</option>
            </optgroup>
            <optgroup label="Western Japanese Dialects">
              <option value="Kansai">関西方言 (Kansai Dialect)</option>
              <option value="Chugoku">中国方言 (Chūgoku Dialect)</option>
              <option value="Shikoku">四国方言 (Shikoku Dialect)</option>
            </optgroup>
            <optgroup label="Kyūshū Dialects">
              <option value="Hakata">博多方言 (Hakata Dialect)</option>
              <option value="Kagoshima">鹿児島方言 (Kagoshima Dialect)</option>
            </optgroup>
            <optgroup label="Hachijo Dialect">
              <option value="Hachijo">八丈方言 (Hachijō Dialect)</option>
            </optgroup>
          </select>
        </div>
      </div>

      <!-- Text Areas -->
      <div class="grid sm:grid-cols-2 gap-4">
        <div class="space-y-2">
          <label class="block text-xs text-neutral-400">Input Text</label>
          <textarea id="inputText" placeholder="Enter text to translate..." class="w-full h-40 p-4 rounded-lg bg-neutral-900 border border-neutral-700 resize-y focus:outline-none focus:ring-2 focus:ring-sky-500"></textarea>
          <div id="charCount" class="text-xs text-neutral-400">0 characters</div>
        </div>
        <div class="space-y-2">
          <label class="block text-xs text-neutral-400">Translation</label>
          <textarea id="outputText" placeholder="Translation will appear here..." class="w-full h-40 p-4 rounded-lg bg-neutral-900 border border-neutral-700 resize-y" readonly></textarea>
        </div>
      </div>

      <!-- Actions -->
      <div class="flex flex-col sm:flex-row gap-3">
        <button id="translateBtn" class="flex-1 inline-flex items-center justify-center gap-2 px-4 py-3 rounded-lg bg-sky-600 hover:bg-sky-500 text-white font-medium disabled:opacity-60 disabled:cursor-not-allowed">
          <span id="translateText">Translate</span>
          <div id="loadingSpinner" class="spinner hidden"></div>
        </button>
        <button id="copyBtn" class="flex-1 px-4 py-3 rounded-lg bg-neutral-700 hover:bg-neutral-600">Copy Translation</button>
        <button id="clearBtn" class="px-4 py-3 rounded-lg bg-rose-600/20 hover:bg-rose-600/30 text-rose-200">Clear</button>
      </div>

      <!-- Messages -->
      <div id="messageBox" class="hidden p-3 rounded-lg text-sm"></div>
    </div>
  </div>

  <script>
    // ===== Configuration =====
    const CONFIG = {
      API_URL: "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash-exp:generateContent",
      MAX_CHARS: 5000,
      API_KEY_STORAGE: 'gemini_api_key'
    };

    // ===== API Key Manager (same behavior/format) =====
    const ApiKeyManager = {
      save(key){ try{ localStorage.setItem(CONFIG.API_KEY_STORAGE, btoa(key)); return true }catch{ return false } },
      load(){ try{ const e = localStorage.getItem(CONFIG.API_KEY_STORAGE); return e ? atob(e) : null }catch{ return null } },
      remove(){ localStorage.removeItem(CONFIG.API_KEY_STORAGE) },
      isValid(k){ return k && k.length > 20 && k.startsWith('AIza') }
    };

    // ===== Elements =====
    const el = {
      providerStatusText: document.getElementById('providerStatusText'),
      toggleProviderBtn: document.getElementById('toggleProviderBtn'),
      apiConfigSection: document.getElementById('apiConfigSection'),
      providerChevron: document.getElementById('providerChevron'),
      apiKeyInput: document.getElementById('apiKeyInput'),
      saveApiKey: document.getElementById('saveApiKey'),
      toggleApiKey: document.getElementById('toggleApiKey'),
      eyeIcon: document.getElementById('eyeIcon'),
      inputLang: document.getElementById('inputLang'),
      outputLang: document.getElementById('outputLang'),
      formalityContainer: document.getElementById('formalityContainer'),
      formalityLevel: document.getElementById('formalityLevel'),
      dialectLevel: document.getElementById('dialectLevel'),
      inputText: document.getElementById('inputText'),
      outputText: document.getElementById('outputText'),
      translateBtn: document.getElementById('translateBtn'),
      translateText: document.getElementById('translateText'),
      loadingSpinner: document.getElementById('loadingSpinner'),
      copyBtn: document.getElementById('copyBtn'),
      clearBtn: document.getElementById('clearBtn'),
      messageBox: document.getElementById('messageBox'),
      charCount: document.getElementById('charCount'),
      swapBtn: document.getElementById('swapBtn'),
    };

    // ===== Helpers =====
    const showMessage = (msg, type='info') => {
      const colors = {
        error: 'bg-rose-500/15 text-rose-200 border border-rose-500/30',
        success: 'bg-emerald-500/15 text-emerald-200 border border-emerald-500/30',
        info: 'bg-sky-500/15 text-sky-200 border border-sky-500/30'
      };
      el.messageBox.className = `p-3 rounded-lg text-sm fade-in ${colors[type]}`;
      el.messageBox.textContent = msg; el.messageBox.classList.remove('hidden');
      if (type === 'success') setTimeout(()=> el.messageBox.classList.add('hidden'), 2500);
    };
    const setLoading = (yes) => {
      el.translateBtn.disabled = yes;
      el.translateText.classList.toggle('hidden', yes);
      el.loadingSpinner.classList.toggle('hidden', !yes);
    };

    // ===== Language Lists (limited + alphabetical) =====
    const LANGS = [
      'English', 'Japanese', 'Korean', 'Simplified Chinese', 'Traditional Chinese'
    ].sort((a,b)=> a.localeCompare(b,'en'));

    function populateLanguageSelects() {
      const inVal = el.inputLang.value || 'English';
      const outVal = el.outputLang.value || 'Korean';

      // Input: all LANGS
      el.inputLang.innerHTML = LANGS.map(l=>`<option value="${l}">${l}</option>`).join('');
      el.inputLang.value = inVal;

      // Output: all except current input
      const outOptions = LANGS.filter(l => l !== el.inputLang.value)
        .map(l=>`<option value="${l}">${l}</option>`).join('');
      el.outputLang.innerHTML = outOptions;
      // If previous outVal equals input, fallback to first available
      el.outputLang.value = (outVal === el.inputLang.value) ? (LANGS.find(l=> l!==el.inputLang.value) || LANGS[0]) : outVal;

      toggleFormality();
    }

    function onInputLangChange(){ populateLanguageSelects(); }
    function onOutputLangChange(){ toggleFormality(); }

    function toggleFormality(){
      const isKoreanOut = el.outputLang.value === 'Korean';
      const isJapaneseOut = el.outputLang.value === 'Japanese';
      el.formalityContainer.classList.toggle('hidden', !isKoreanOut);
      document.getElementById('jpFormalityContainer').classList.toggle('hidden', !isJapaneseOut);
    }

    function swapLanguages(){
      const temp = el.inputLang.value;
      const tempText = el.inputText.value;
      el.inputLang.value = el.outputLang.value; // may not exist in input yet, so repopulate
      populateLanguageSelects();
      el.outputLang.value = temp; // will be auto-removed if same as input; repopulate again
      populateLanguageSelects();
      // swap text
      el.inputText.value = el.outputText.value;
      el.outputText.value = tempText;
      updateCharCount();
    }

    function updateCharCount(){ el.charCount.textContent = `${el.inputText.value.length} characters`; }

    function updateProviderStatus(){
      const key = ApiKeyManager.load();
      const ok = ApiKeyManager.isValid(key);
      el.providerStatusText.textContent = ok ? 'Translator Configured ✓' : 'Configure Translator ⚠';
      el.providerStatusText.className = ok ? 'text-emerald-300' : 'text-red-400';
      el.translateBtn.disabled = !ok;
      if (ok && !el.apiKeyInput.value) el.apiKeyInput.value = key;
    }

    function toggleProviderSection(){
      const hidden = el.apiConfigSection.classList.contains('hidden');
      el.apiConfigSection.classList.toggle('hidden');
      el.providerChevron.style.transform = hidden ? 'rotate(180deg)' : 'rotate(0deg)';
    }

    function toggleApiKeyVisibility(){
      const isPassword = el.apiKeyInput.type === 'password';
      el.apiKeyInput.type = isPassword ? 'text' : 'password';
    }

    function saveApiKey(){
      const key = el.apiKeyInput.value.trim();
      if (!key) return showMessage('Please enter an API key.', 'error');
      if (!ApiKeyManager.isValid(key)) return showMessage("Invalid API key format. Gemini API keys should start with 'AIza'.", 'error');
      ApiKeyManager.save(key) ? (showMessage('API key saved successfully!','success'), updateProviderStatus(), setTimeout(()=>toggleProviderSection(), 800)) : showMessage('Failed to save API key. Try again.','error');
    }

    // ===== Translate =====
    async function translateText(){
      const apiKey = ApiKeyManager.load();
      if (!ApiKeyManager.isValid(apiKey)) return showMessage('Please configure your translation provider first.','error');
      const inputLang = el.inputLang.value;
      const outputLang = el.outputLang.value;
      const text = el.inputText.value.trim();
      if (!text) return showMessage('Please enter some text to translate.','error');
      if (text.length > CONFIG.MAX_CHARS) return showMessage(`Text is too long. Max ${CONFIG.MAX_CHARS} characters.`, 'error');

      setLoading(true); el.messageBox.classList.add('hidden');
      try {
        let prompt = `You are a professional translator. Translate the following text that is between %% from ${inputLang} to ${outputLang}. Translate ALL content literally and accurately, including any profanity, slang, or colloquial expressions. Do not censor, modify, or refuse to translate any words.`;
        if (outputLang === 'Korean') {
          const formality = el.formalityLevel.value;
          const dialect = el.dialectLevel.value;
          prompt += ` Use the ${formality} style`;
          if (dialect !== 'Standard Korean') prompt += ` and translate using ${dialect} characteristics and expressions`;
          prompt += '.';
        }

        if (outputLang === 'Japanese') {
          const jpFormality = document.getElementById('jpFormalityLevel').value;
          const jpDialect = document.getElementById('jpDialectLevel').value;
          prompt += ` Use the ${jpFormality} style`;
          if (jpDialect !== '') prompt += ` and apply features of the ${jpDialect}.`;
          prompt += '.';
        }
        prompt += `\n\nText to translate: %%${text}%%\n\nProvide ONLY the translation, no explanations.`;

        const payload = {
          contents: [{ parts: [{ text: prompt }] }],
          generationConfig: { temperature: 0.3, maxOutputTokens: 2048, topP: 0.95, topK: 40 },
          safetySettings: [
            { category: 'HARM_CATEGORY_HARASSMENT', threshold: 'BLOCK_NONE' },
            { category: 'HARM_CATEGORY_HATE_SPEECH', threshold: 'BLOCK_NONE' },
            { category: 'HARM_CATEGORY_SEXUALLY_EXPLICIT', threshold: 'BLOCK_NONE' },
            { category: 'HARM_CATEGORY_DANGEROUS_CONTENT', threshold: 'BLOCK_NONE' },
          ],
        };

        const controller = new AbortController();
        const timeoutId = setTimeout(()=> controller.abort(), 30000);
        const res = await fetch(`${CONFIG.API_URL}?key=${apiKey}`, {
          method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload), signal: controller.signal,
        });
        clearTimeout(timeoutId);
        if (!res.ok) {
          const err = await res.json().catch(()=>({error:{message:`HTTP ${res.status}`}}));
          if (res.status === 400 && err.error?.message?.includes('API_KEY_INVALID')) { ApiKeyManager.remove(); updateProviderStatus(); }
          throw new Error(err.error?.message || `HTTP ${res.status}`);
        }
        const data = await res.json();
        if (data.promptFeedback?.blockReason) throw new Error(`Content blocked by safety filters: ${data.promptFeedback.blockReason}`);
        const candidate = data.candidates?.[0];
        const translated = candidate?.content?.parts?.[0]?.text;
        if (!translated) throw new Error('No translation text found in response.');

        // 🔹 Clean output before displaying
        let cleaned = translated.trim();
        cleaned = cleaned.replace(/^%%+|%%+$/g, "");  // strip %% at start/end
        cleaned = cleaned.replace(/^"+|"+$/g, "");    // strip quotes at start/end
        el.outputText.value = cleaned.trim();

        showMessage('Translation completed successfully!','success');
      } catch (e) {
        showMessage(`Translation failed: ${e.message}`, 'error');
      } finally { setLoading(false); }
    }

    function copyText(){
      const t = el.outputText.value; if (!t) return showMessage('No text to copy.','error');
      navigator.clipboard.writeText(t).then(()=> showMessage('Translation copied to clipboard!','success')).catch(()=> showMessage('Failed to copy. Select and copy manually.','error'));
    }

    function clearAll(){ el.inputText.value = ''; el.outputText.value = ''; el.messageBox.classList.add('hidden'); updateCharCount(); el.inputText.focus(); }

    // ===== Events =====
    el.toggleProviderBtn.addEventListener('click', toggleProviderSection);
    el.toggleApiKey.addEventListener('click', toggleApiKeyVisibility);
    el.saveApiKey.addEventListener('click', saveApiKey);
    el.translateBtn.addEventListener('click', translateText);
    el.copyBtn.addEventListener('click', copyText);
    el.clearBtn.addEventListener('click', clearAll);
    el.swapBtn.addEventListener('click', swapLanguages);

    el.apiKeyInput.addEventListener('keydown', (e)=>{ if (e.key === 'Enter'){ e.preventDefault(); saveApiKey(); } });
    el.inputText.addEventListener('input', updateCharCount);

    // Language mutual exclusion
    el.inputLang.addEventListener('change', onInputLangChange);
    el.outputLang.addEventListener('change', onOutputLangChange);

    // ===== Init =====
    (function init(){
      populateLanguageSelects();
      // Defaults: English -> Korean
      el.inputLang.value = 'English';
      populateLanguageSelects();
      el.outputLang.value = 'Korean';
      toggleFormality();
      updateProviderStatus();
      updateCharCount();
      el.inputText.focus();
    })();
  </script>
</body>
</html>
